import Foundation

// MARK: - Coach Card

/// A coaching card generated by the InsightsEngine.
/// All fields are deterministic and evidence-based.
///
/// Localization Note: This struct contains both rendered strings (title, oneLiner, etc.)
/// and localization-ready structured content (localizedContent). The rendered strings
/// are used by the current UI. When localization is implemented, the localizedContent
/// can be used to generate localized strings without changing the card structure.
struct CoachCard: Identifiable, Codable, Equatable {
    /// Unique identifier for this card instance
    let id: String

    /// Child this card is for
    let childId: String

    /// Priority for ranking (higher = more important)
    let priority: Int

    /// Short, action-oriented title (rendered)
    let title: String

    /// One-liner explanation (rendered)
    let oneLiner: String

    /// Concrete action steps (max 3, rendered)
    let steps: [String]

    /// One sentence explaining why this matters (rendered)
    let whySummary: String

    /// IDs of events that support this insight
    let evidenceEventIds: [String]

    /// Call to action
    let cta: CoachCTA

    /// When this card expires and should be regenerated
    let expiresAt: Date

    /// Template ID used to generate this card (for cooldown tracking)
    let templateId: String

    /// Time window the evidence is from
    let evidenceWindow: Int // days

    /// Primary entity ID (goal or behavior) for stable key generation
    let primaryEntityId: String?

    /// Structured content for future localization support.
    /// Contains keys and arguments that can be used with localization tables.
    let localizedContent: LocalizedContent?

    // MARK: - Localized Content

    /// Structured content for localization.
    /// Keys follow the pattern: "insights.\(templateId).\(field)"
    struct LocalizedContent: Codable, Equatable {
        let titleKey: String
        let titleArgs: [String: String]

        let oneLinerKey: String
        let oneLinerArgs: [String: String]

        let stepsKeys: [String]
        let stepsArgs: [[String: String]]

        let whyKey: String
        let whyArgs: [String: String]
    }

    // MARK: - Computed Properties

    var hasValidEvidence: Bool {
        !evidenceEventIds.isEmpty
    }

    var stepCount: Int {
        min(steps.count, 3)
    }

    /// Deterministic key for diffing and deduplication.
    /// Stable across regenerations for the same insight.
    var stableKey: String {
        let entityPart = primaryEntityId ?? "none"
        return "\(childId):\(templateId):\(entityPart):\(evidenceWindow)"
    }
}

// MARK: - Coach CTA

/// Call to action for a coaching card.
enum CoachCTA: Codable, Equatable {
    case openAddMoment(childId: String)
    case openGoalDetail(goalId: String)
    case openGoalsPicker(childId: String)
    case openHistory(childId: String, filter: HistoryFilter)
    case openManageBehaviors(childId: String)

    // MARK: - Display Properties

    var buttonText: String {
        switch self {
        case .openAddMoment:
            return "Log a moment"
        case .openGoalDetail:
            return "View goal"
        case .openGoalsPicker:
            return "Set a goal"
        case .openHistory:
            return "View history"
        case .openManageBehaviors:
            return "Manage behaviors"
        }
    }

    var iconName: String {
        switch self {
        case .openAddMoment:
            return "plus.circle.fill"
        case .openGoalDetail:
            return "star.circle.fill"
        case .openGoalsPicker:
            return "target"
        case .openHistory:
            return "clock.arrow.circlepath"
        case .openManageBehaviors:
            return "list.bullet.rectangle"
        }
    }
}

// MARK: - History Filter (for CTA)

/// Filter options for history navigation.
struct HistoryFilter: Codable, Equatable {
    let typeFilter: HistoryTypeFilterOption
    let behaviorId: String?
    let timePeriod: Int // days

    enum HistoryTypeFilterOption: String, Codable {
        case all
        case positive
        case challenges
        case routines
    }

    static let allRecent = HistoryFilter(
        typeFilter: .all,
        behaviorId: nil,
        timePeriod: 7
    )

    static func challenges(days: Int) -> HistoryFilter {
        HistoryFilter(typeFilter: .challenges, behaviorId: nil, timePeriod: days)
    }

    static func positive(days: Int) -> HistoryFilter {
        HistoryFilter(typeFilter: .positive, behaviorId: nil, timePeriod: days)
    }

    static func routines(days: Int) -> HistoryFilter {
        HistoryFilter(typeFilter: .routines, behaviorId: nil, timePeriod: days)
    }

    static func behavior(_ id: String, days: Int) -> HistoryFilter {
        HistoryFilter(typeFilter: .all, behaviorId: id, timePeriod: days)
    }
}

// MARK: - Insufficient Data Card

extension CoachCard {

    /// Creates a gentle "insufficient data" card suggesting to log more moments.
    static func insufficientData(
        childId: String,
        childName: String,
        reason: String
    ) -> CoachCard {
        let localizedContent = LocalizedContent(
            titleKey: "insights.insufficient_data.title",
            titleArgs: [:],
            oneLinerKey: "insights.insufficient_data.one_liner",
            oneLinerArgs: ["childName": childName],
            stepsKeys: [
                "insights.insufficient_data.step_1",
                "insights.insufficient_data.step_2",
                "insights.insufficient_data.step_3"
            ],
            stepsArgs: [[:], [:], [:]],
            whyKey: "insights.insufficient_data.why",
            whyArgs: ["reason": reason]
        )

        return CoachCard(
            id: "insufficient_data-\(childId)",
            childId: childId,
            priority: 1,
            title: "Keep building the picture",
            oneLiner: "A few more moments will help surface patterns for \(childName).",
            steps: [
                "Log when you notice something positive",
                "Capture challenges too - they're data, not failure",
                "Even 1-2 moments a day reveals patterns over time"
            ],
            whySummary: reason,
            evidenceEventIds: [],
            cta: .openAddMoment(childId: childId),
            expiresAt: Calendar.current.date(byAdding: .day, value: 1, to: Date()) ?? Date(),
            templateId: "insufficient_data",
            evidenceWindow: 0,
            primaryEntityId: nil,
            localizedContent: localizedContent
        )
    }
}

// MARK: - Priority Levels

enum CardPriority: Int {
    case low = 1
    case medium = 2
    case high = 3
    case urgent = 4
    case critical = 5

    var displayName: String {
        switch self {
        case .low: return "Low"
        case .medium: return "Medium"
        case .high: return "High"
        case .urgent: return "Urgent"
        case .critical: return "Critical"
        }
    }
}
